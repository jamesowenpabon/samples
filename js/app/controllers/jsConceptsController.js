define(["app"],function(sampleApp){sampleApp.register.controller("jsconcepts",function($sce,$scope,$rootScope,exSrcConSrv,arryObjSrv,logOutputSrv){function funcState(invoType){this.name="funcState",thisResult+="| "+this.name+" "+invoType+"<br>",thisResult+="| this = "+this+"<br>"}function PersonObjConstr(){this.firstname="John",this.lastname="Doe",this.greetFullName=function(){return"PersonObjConstr says: Hello "+this.firstname+" "+this.lastname}}var jc=this;$rootScope.exSrcObj=new exSrcConSrv.exSrcCon({html:{label:"HTML",src:"pages/jsconcepts.html",icon:"fa fa-html5"},controller:{label:"jsConceptsCtrlr",src:"srcjs/app/controllers/jsConceptsController-src.js",icon:"fa fa-dot-circle-o"},css:{label:"SCSS",src:"scss/app/js-concepts.scss",psrc:"css/app/js-concepts.css",icon:"fa fa-css3"}}),$rootScope.exSrcLinkArray=arryObjSrv.parseObj($rootScope.exSrcObj),$scope.trust=$sce.trustAsHtml;var localGlobal=0,globalVariable=5,myIIFE=function(localGlobal,localWindow){return localGlobal=100,setTimeout(function(){localWindow.document.getElementById("iife").innerHTML="YES"}),localGlobal}(globalVariable,window),iifeResult="globalVariable = "+globalVariable+"<br>localGlobal = "+localGlobal+"<br>myIIFE = "+myIIFE+"<br>",newSpace=newSpace||{};!function(o){o.prop1="NewSpace Value",o.func1=function(){}}(newSpace);var prop1="Global Value";newSpace.func1();var namespaceResult="----------------------<br>| This is Global func1<br>| Global prop1: "+prop1+"<br>| NewSpace prop1: "+newSpace.prop1+"<br>----------------------<br>----------------------<br>| This is NewSpace func1<br>| NewSpace prop1: "+newSpace.prop1+"<br>| Global prop1: "+prop1+"<br>----------------------<br>",arithmetic=function(){var counter=0;return{add:function(){return counter+=1,counter.toString()},subtract:function(){return counter-=1,counter.toString()}}}(),funcExp=function(invoType){this.name="funcExp",thisResult+="| "+this.name+" "+invoType+"<br>",thisResult+="| this = "+this+"<br>"},obj={name:"obj",method1:function(invoType){thisResult+="| "+this.name+" "+invoType+"<br>",thisResult+="| this = "+this+"<br>"}},thisResult="---------------------------<br>";funcExp("Invoke As Function"),thisResult+="| window.name: "+window.name+"<br>";var invoExpAsConst=new funcExp("Invoke with Constructor");thisResult+="| invoExpAsConst.name: "+invoExpAsConst.name+"<br>",thisResult+="---------------------------<br>",thisResult+="---------------------------<br>",funcState("Invoke As Function"),thisResult+="| window.name: "+window.name+"<br>";var invoStaAsConst=new funcState("Invoke with Constructor");thisResult+="| invoStaAsConst.name: "+invoStaAsConst.name+"<br>",thisResult+="---------------------------<br>",thisResult+="---------------------------<br>",obj.method1("Invoke As Method"),thisResult+="| obj.name: "+obj.name+"<br>";var objAsConst=new obj.method1("Invoke with Constructor");thisResult+="| objAsConst.name: "+objAsConst.name+"<br>",thisResult+="---------------------------<br>",thisResult+="---------------------------<br>",funcExp.call(obj,"Invoke With Function Method"),thisResult+="| obj.name: "+obj.name+"<br>",thisResult+="---------------------------<br>";var personObjLit={firstname:"John",lastname:"Doe",greetFullName:function(){return"personObjLit says: Hello "+this.firstname+" "+this.lastname}},james=new PersonObjConstr;james.firstname="James",james.lastname="Pabon",PersonObjConstr.prototype.formalGreet=function(){return"Good day "+this.lastname+", "+this.firstname};var valerie=Object.create(personObjLit);valerie.firstname="Valerie",personObjLit.formalGreet=function(){return"Good day "+this.lastname+", "+this.firstname};var protoResult="---------------------------</br>";protoResult+="| Create James with PersonObjConstr() & call james.greetFullName()</br>";var james=new PersonObjConstr;protoResult+="| "+james.greetFullName()+"</br>",james.firstname="James",james.lastname="Pabon",protoResult+="| Change james.firstname: "+james.firstname+"</br>",protoResult+="| Change james.lastname: "+james.lastname+"</br>",protoResult+="| Call james.greetFullName() again.</br>",protoResult+="| "+james.greetFullName()+"</br>",protoResult+="---------------------------</br>",protoResult+="---------------------------</br>",protoResult+="| Add .formalGreet() to PersonObjConstr.prototype</br>",PersonObjConstr.prototype.formalGreet=function(){return"Good day "+this.lastname+", "+this.firstname},protoResult+="| Call james.formalGreet()</br>",protoResult+="| "+james.formalGreet()+"</br>",protoResult+="---------------------------</br>",protoResult+="---------------------------</br>",protoResult+="| Call personObjLit.greetFullName()</br>",protoResult+="| "+personObjLit.greetFullName()+"</br>",protoResult+="| Create Valerie object with Object.create(personObjLit)</br>";var valerie=Object.create(personObjLit);valerie.firstname="Valerie",protoResult+="| Change valerie.firstname: "+valerie.firstname+"</br>",protoResult+="| Call valerie.greetFullName() again.</br>",protoResult+="| "+valerie.greetFullName()+"</br>",protoResult+="---------------------------</br>",protoResult+="---------------------------</br>",protoResult+="| Add .formalGreet() to personObjLit</br>",personObjLit.formalGreet=function(){return"Good day "+this.lastname+", "+this.firstname},protoResult+="| Call valerie.formalGreet()</br>",protoResult+="| "+valerie.formalGreet()+"</br>",protoResult+="---------------------------</br>",jc.concept=[{name:"IIFE",def:"A <dfn><abbr title='Immediately Invoked Function Element'>IIFE</abbr></dfn> is a JavaScript function that runs as soon as it is defined.",cite:"MDN - https://developer.mozilla.org/en-US/docs/Glossary/IIFE",defDesc:"IIFE's are commonly used by JS libraries and frameworks to place their code within a local scope thus avoiding naming collisions with other libraries and application JavaScript code. The code below shows how the IIFE creates a new execution context where a new varibale named <code>localGlobal</code> is mutated and the local reference of the window object is utalized to modify the DOM. Note that the two varibales named <code>localGlobal</code> point to seperate locations in memory for their values because of the differnt executions contexts in which they were created.",code:'\n	 // IIFE\n\n	 var localGlobal = 0;\n	 var globalVariable = 5;\n	 var myIIFE = (function(localGlobal, localWindow) {\n		 localGlobal = 100;\n		 localWindow.document.getElementById(("testDiv")).innerHTML="YES";\n		 return localGlobal;\n	 })(globalVariable, window);\n\n	 console.log("globalVariable = " + globalVariable);\n	 console.log("localGlobal = " + localGlobal);\n	 console.log("myIIFE = " + myIIFE);\n',resultsLabel:"<b>console.log output</b><br>",controls:{objPrpName:"iife",type:"test-div",templateHead:"Contents of testDiv"},result:iifeResult,xboxDesc:"The above shows the <code>globalVariable</code> maintaining  its value, two diffent values of the two <code>localGlobal</code> varibles, the value of <code>myIIFE</code> which is assigned the return value of the anonymous function and the window object referenced within the IIFE local scope setting the HTML of <code>#testDiv</code>"},{name:"Namespacing",def:"A <dfn>Namespace</dfn> is a seperate execution context which encapsulates a block of code to avoid collisions with other objects or variables.",cite:"Me",defDesc:'The code below shows a new execution context created by an  IFFE. An empty objected named <code>var newSpace</code> is defined, and set as an argument for the function. The <code>o.prop1 = "NewSpace Value"</code> property and the <code>o.func1 = function() {...}</code> method are defined  on the empty object and can then be accessed via <code>newSpace.prop1</code> &  <code>newSpace.func1</code> so as not to collide with the global <code>var prop1</code> & <code>var func1</code>.',code:'\n	 // Namespacing\n\n	 var newSpace = newSpace || {};\n	 (function(o) {\n		 console.log(o);\n		 o.prop1 = "NewSpace Value";\n		 o.func1 = function() {\n			 console.log("----------------------");\n			 console.log("| This is NewSpace func1");\n			 console.log("| NewSpace prop1: "+o.prop1);\n			 console.log("| Global prop1: "+prop1);\n			 console.log("----------------------");\n		 }\n	 })(newSpace)\n\n	 var	prop1 = "Global Value";\n	 var func1 = function() {\n		 console.log("----------------------");\n		 console.log("| This is Global func1");\n		 console.log("| Global prop1: "+prop1);\n		 console.log("| NewSpace prop1: "+newSpace.prop1);\n		 console.log("----------------------");\n	 }()\n	 newSpace.func1();\n',resultsLabel:"<b>console.log output</b><br>",controls:{objPrpName:"namespace"},result:namespaceResult,xboxDesc:"The above output shows how creating a name space prevents variables of the same name from colliding."},{name:"Closures",def:"A <dfn>closure</dfn> is a special kind of object that combines two things: a function, and the environment in which that function was created.",cite:"MDN - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures",defDesc:"The code below shows a closure around the <code>add: function(){...}</code> and <code>subtract: function(){...}</code>. A closure is a special property of JavaScript which preserves the scope chain for functions which have utalized free variables that were created in execution contexts which are no longer in memeory. This allows the <code>add: function(){return counter += 1;}</code> and <code>subtract: function(){return counter -= 1;}</code> to retain access to the counter variable even after the anonymous execution context which created it has ended. In the example <code>var arithmetic</code> is assigned an <abbr title='Immediately Invoked Function Element'>IFFE</abbr>, however creating a closure does not need to utalize immediately invoked functions.",code:"\n	 // Closures\n\n	 var arithmetic = (function () {\n		 var counter = 0;\n		 return {\n			 add: function(){return counter += 1;},\n			 subtract: function(){return counter -= 1;}\n		 }\n	 })();",resultsLabel:"<b>count</b> = ",controls:{type:"button-two",objPrpName:"closure",buttonProps:{b1text:"Add",b1Func:"add",b2text:"subtract",b2Func:"subtract"}},result:"0",action:function(operation){this.result=arithmetic[operation]()},xboxDesc:"Click the buttons above to modify the value of the <code>counter</code> variable made possible by the closure reference around <code>add()</code> & <code>subtract()</code> functions."},{name:"this",def:"<dfn><code>this</code></dfn> is a JavaScript keyword with a value that is determined by its lexical context and method of invocation.",cite:"Me",defDesc:"The code below shows three differnt function definitions, function expression, function statement & function as a method of an object. There are 4 different ways to invoke a function, as a function, with a constructor, as an object method and with a function method. When invoked as a function, <code>this</code> references the Global object. When invoked with a constructor <code>this</code> references  the an empy object created by use of the <code>new</code> keyword  which is returned to the variable in constructor assignment. When invoked as a method of an object <code>this</code> references the object the invoked method is sitting on. Note however that if a method is invoked with a constructor the <code>this</code> variable still references the empy object created by use of the <code>new</code> keyword which is why <code>objAsConst.name</code> is undefined in the output below. Finally when invoked with a function method this takes the value of the context passed to it which is why <code>obj.name</code> is equal to <code>funcExp</code> in the final example below.",code:'\n	 // this Example\n\n	 var funcExp = function(invoType) {\n		 this.name = "funcExp";\n		 console.log("| " + this.name + " " + invoType);\n		 console.log("| this = " + this);\n	 }\n\n	 function funcState(invoType) {\n		 this.name = "funcState";\n		 console.log("| " + this.name + " " + invoType);\n		 console.log("| this = " + this);\n	 }\n\n	 var obj = {\n		 name : "obj",\n		 method1 : function(invoType) {\n			 console.log("| " + this.name + " " + invoType);\n			 console.log("| this = " + this);\n		 }\n	 }\n\n	 console.log("---------------------------");\n	 funcExp("Invoke As Function");\n	 console.log("| window.name: " + window.name);\n	 var invoExpAsConst = new funcExp("Invoke with Constructor");\n	 console.log("| invoExpAsConst.name: " + invoExpAsConst.name);\n	 console.log("---------------------------");\n\n	 console.log("---------------------------");\n	 funcState("Invoke As Function");\n	 console.log("| window.name: " + window.name);\n	 var invoStaAsConst = new funcState("Invoke with Constructor");\n	 console.log("| invoStaAsConst.name: " + invoStaAsConst.name);\n	 console.log("---------------------------");\n\n	 console.log("---------------------------");\n	 obj.method1("Invoke As Method");\n	 console.log("| obj.name: " + obj.name);\n	 var objAsConst = new obj.method1("Invoke with Constructor");\n	 console.log("| objAsConst.name: " + objAsConst.name);\n	 console.log("---------------------------");\n\n	 console.log("---------------------------");\n	 funcExp.call(obj, "Invoke With Function Method");\n	 console.log("| obj.name: " + obj.name);\n	 console.log("---------------------------");\n',resultsLabel:"<b>console.log output</b><br>",controls:{objPrpName:"this"},result:thisResult,xboxDesc:"The above output shows the value of <code>this</code> as well as the <code>name</code> variable under differnt lexical & invocation conditions."},{name:"Object Creation and Prototypal Inheritance",def:"<dfn>Prototypal Inheritance</dfn> is the ability of any JavaScript object to access properties and methods of its prototype (the object from which it was created).",cite:"Me",defDesc:"The code below shows three methods of creating an object, Object Literal syntax, a Function Constructor and <code>Object.create()</code>. Object literal syntax simply creates and object on the fly and as such its <code>__prototype__</code> is the <code>Object</code> object and it will have access to all the properties and methods of <code>Object</code>. <p></p>The function constructor has a special property named <code>.prototype</code>. This property will become the <code>__prototype__</code> of any objects created by the function constructor. All properties and methods added to the <code>.prototype</code> property of a function contructor will be available to all objects it creates. <p></p>Creating objects with <code>Object.create()</code> utilizes an object literal as a <code>__prototype__</code> for the objects created by this method. All properties and methods added to the object literal will be available to all objects created from it.",code:'\n	 //Object Example\n\n	 // Function Constructor\n	 function PersonObjConstr()	{\n		 this.firstname = "John";\n		 this.lastname = "Doe";\n		 this.greetFullName = function()	{\n			 return "PersonObjConstr says: Hello " + this.firstname +\n				", " + this.lastname;\n		 };\n	 }\n\n	 // Object Literal\n	 var personObjLit = {\n		 firstname : "John",\n		 lastname: "Doe",\n		 greetFullName : function() {\n				return "personObjLit says: Hello " + this.firstname +\n				", " + this.lastname;\n		 }\n	 };\n\n	 console.log("---------------------------");\n	 console.log("| Create James with PersonObjConstr() & call james.greetFullName()");\n	 var james = new PersonObjConstr();\n	 console.log("| " + james.greetFullName());\n\n	 james.firstname = "James";\n	 james.lastname = "Pabon";\n	 console.log("| Change james.firstname: " + james.firstname);\n	 console.log("| Change james.lastname: " + james.lastname);\n	 console.log("| Call james.greetFullName() again.");\n	 console.log("| " + james.greetFullName());\n	 console.log("---------------------------");\n\n	 console.log("---------------------------");\n	 console.log("| Add .formalGreet() to PersonObjConstr.prototype");\n	 PersonObjConstr.prototype.formalGreet = function() {\n		 return "Good day " + this.lastname + ", " + this.firstname;\n	 };\n\n	 console.log("| Call james.formalGreet()");\n	 console.log("| " + james.formalGreet());\n	 console.log("---------------------------");\n\n	 console.log("---------------------------");\n	 console.log("| Call personObjLit.greetFullName()");\n	 console.log(personObjLit.greetFullName());\n\n	 console.log("| Create Valerie object with Object.create(personObjLit)");\n	 var valerie = Object.create(personObjLit);\n\n	 valerie.firstname = "Valerie";\n	 console.log("| Change valerie.firstname: " + valerie.firstname);\n	 console.log("| Call valerie.greetFullName() again.");\n	 console.log("| " + valerie.greetFullName());\n	 console.log("---------------------------");\n\n	 console.log("---------------------------");\n	 console.log("| Add .formalGreet() to personObjLit");\n	 personObjLit.formalGreet = function() {\n		 return "Good day " + this.lastname + ", " + this.firstname;\n	 };\n\n	 console.log("| Call valerie.formalGreet()");\n	 console.log("| " + valerie.formalGreet());\n	 console.log("---------------------------");\n',resultsLabel:"<b>console.log output</b><br>",controls:{objPrpName:"proto"},result:protoResult,xboxDesc:"<p>The above output first shows the creation of the <code>james</code> object by a function constructor and the addition of <code>.formalGreet()</code> to the <code>.prototype</code> property of <code>PersonObjConstr</code> making it available to the james object through prototypal inheritance. </p><p>Next it shows the creation of the <code>valerie</code> object by using Object.create() and making the <code>personObjLit</code> object literal, the <code>__proto__</code> of the <code>valerie</code> object. Similarly <code>.formalGreet()</code> is added to <code>personObjLit</code> making it available to the <code>valerie</code> object through prototypal inheritance.</p>"}],console.log("-----jc Controller Scope-----"),console.log(jc)})});
//# sourceMappingURL=../maps/controllers/jsConceptsController.js.map
